<!DOCTYPE html>
<html>
<head>
  <title>Robot Game</title>
  <style>
    .board {
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      grid-template-rows: repeat(16, 1fr);
      gap: 2px;
      width: 320px;
      height: 320px;
    }
    .cell {
      background-color: lightgray;
      border-radius: 50%;
      cursor: pointer;
    }
    .cell.human {
      background-color: blue;
    }
    .cell.robot {
      background-color: red;
    }
    .cell.fire {
      background-color: orange;
    }
  </style>
</head>
<body>
  <h1>Robot Game</h1>
  <div class="board"></div>
  <script>
    
   class Position {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  isEqual(o) {
    return this.x === o.x && this.y === o.y;
  }

  isNotEqual(o) {
    return !this.isEqual(o);
  }

  add(o) {
    return new Position(this.x + o.x, this.y + o.y);
  }

  subtract(o) {
    return new Position(this.x - o.x, this.y - o.y);
  }

  addValue(val) {
    return new Position(this.x + val, this.y + val);
  }

  subtractValue(val) {
    return new Position(this.x - val, this.y - val);
  }

  multiply(val) {
    return new Position(this.x * val, this.y * val);
  }

  divide(val) {
    return new Position(this.x / val, this.y / val);
  }

  distance(o) {
    const diff = this.subtract(o);
    return Math.sqrt(diff.x * diff.x + diff.y * diff.y);
  }

  distanceSquared(o) {
    const diff = this.subtract(o);
    return diff.x * diff.x + diff.y * diff.y;
  }

  manhattanDistance(o) {
    return Math.abs(this.x - o.x) + Math.abs(this.y - o.y);
  }

  static create(x, y) {
    return new Position(x, y);
  }
}

    
class Board {
  static WIDTH = 45;
  static HEIGHT = 30;

  constructor() {
    this.cells_ = [];
    for (let w = 0; w < Board.WIDTH; ++w) {
      this.cells_[w] = [];
      for (let h = 0; h < Board.HEIGHT; ++h) {
        this.cells_[w][h] = Occupant.EMPTY;
      }
    }

    this.human_position_ = { x: -1, y: -1 };
    this.robot_positions_ = [];
    this.num_robots_ = 0;
    this.num_fires_ = 0;
    this.init( 1 );
  }

init(round) {
  // RESET
  this.clear_board();

  // HUMAN
  this.human_position_ = STARTING_POSITION;
  this.cell(this.human_position_) = Occupant.HUMAN;

  // ROBOTS
  this.robot_positions_ = [];
  var robotCount = this.nrobots_per_round(round);
  if (this.robot_positions_.length < 100) {
    // Use different algorithm if the robot count is << the number of cells
    for (var i = 0; i < robotCount; i++) {
      var robot = { x: random_x(), y: random_y() };
      while (this.cell(robot) != Occupant.EMPTY) {
        robot.x = random_x();
        robot.y = random_y();
      }
      this.robot_positions_.push(robot);
      this.cell(robot) = Occupant.ROBOT;
    }
  } else {
    // This can be very constexpr
    var empty_positions = [];
    var totalCells = HEIGHT * WIDTH;
    empty_positions.reserve(totalCells - 1);
    for (var w = 0; w < WIDTH; w++) {
      for (var h = 0; h < HEIGHT; h++) {
        var p = { x: w, y: h };
        if (p != STARTING_POSITION) {
          empty_positions.push(p);
        }
      }
    }

    var g = new Math.seedrandom();
    shuffle(empty_positions, g);

    for (var i = 0; i < robotCount; i++) {
      this.robot_positions_[i] = empty_positions[i];
      this.cell(this.robot_positions_[i]) = Occupant.ROBOT;
    }
  }
}

  
  setCell(x, y, value) {
    this.cells_[x][y] = value;
  }

  cell(position) {
    if (position.x < 0 || position.x >= Board.WIDTH || position.y < 0 || position.y >= Board.HEIGHT) {
      return Occupant.OOB;
    }
    return this.cells_[position.x][position.y];
  }

  isInsideBoard(position) {
    return position.x >= 0 && position.x < Board.WIDTH && position.y >= 0 && position.y < Board.HEIGHT;
  }

  moveHumanTo(x, y) {
    if (this.cell({ x, y }) !== Occupant.EMPTY) {
      return MoveResult.INVALID_MOVE;
    }

    this.cells_[this.human_position_.x][this.human_position_.y] = Occupant.EMPTY;
    this.human_position_ = { x, y };
    this.cells_[x][y] = Occupant.HUMAN;

    return this.moveRobots1Step();
  }

move_robots_1_step(human_is_safe) {
  // Clear robots from the board
  for (let w = 0; w < Board.WIDTH; ++w) {
    for (let h = 0; h < Board.HEIGHT; ++h) {
      if (this.cells_[w][h] === Occupant.ROBOT) {
        this.cells_[w][h] = Occupant.EMPTY;
      }
    }
  }

  // Some robots will be deleted if they collide with each other or with fire
  const robotsToDelete = new Set();

  // Keep temporary track of robots in case they collide
  const robotIndices = new Array(Board.WIDTH);
  for (let i = 0; i < Board.WIDTH; ++i) {
    robotIndices[i] = new Array(Board.HEIGHT).fill(-1);
  }

  for (let r = 0; r < this.robot_positions_.length; ++r) {
    let pos = this.robot_positions_[r];

    if (this.human_position_.x < pos.x) pos.x -= 1;
    else if (this.human_position_.x > pos.x) pos.x += 1;

    if (this.human_position_.y < pos.y) pos.y -= 1;
    else if (this.human_position_.y > pos.y) pos.y += 1;

    if (human_is_safe && pos.x === this.human_position_.x && pos.y === this.human_position_.y) {
      // This is rare, but just have the robot take one step to the left or right
      if (pos.x === 0) ++pos.x; // Don't go out of bounds
      else --pos.x;
    }

    const cellValue = this.cell(pos);
    switch (cellValue) {
      case Occupant.EMPTY:
        robotIndices[pos.x][pos.y] = r;
        this.cells_[pos.x][pos.y] = Occupant.ROBOT;
        break;
      case Occupant.ROBOT:
        const otherRobotInd = robotIndices[pos.x][pos.y];
        robotsToDelete.add(otherRobotInd);
        robotsToDelete.add(r);
        this.cells_[pos.x][pos.y] = Occupant.FIRE;
        break;
      case Occupant.HUMAN:
        return MoveResult.YOU_LOSE;
      case Occupant.FIRE:
        robotsToDelete.add(r);
        break;
      case Occupant.OOB:
        break;
    }
  }

  for (const index of robotsToDelete) {
    this.robot_positions_.splice(index, 1);
  }

  if (this.robot_positions_.length === 0) {
    return MoveResult.YOU_WIN_ROUND;
  }

  return MoveResult.CONTINUE;
}


  placeRandomly(occupant, count) {
    let placedCount = 0;

    while (placedCount < count) {
      const x = Math.floor(Math.random() * Board.WIDTH);
      const y = Math.floor(Math.random() * Board.HEIGHT);

      if (this.cell({ x, y }) === Occupant.EMPTY) {
        this.cells_[x][y] = occupant;

        if (occupant === Occupant.ROBOT) {
          this.robot_positions_.push({ x, y });
          this.num_robots_++;
        } else if (occupant === Occupant.FIRE) {
          this.num_fires_++;
        }

        placedCount++;
      }
    }
  }

  isGameOver() {
    return this.cell(this.human_position_) !== Occupant.HUMAN;
  }
}

class RobotsGame {
  constructor(round = 1, tele = 0) {
    this.board_ = new Board();
    this.round_ = round;
    this.n_safe_teleports_remaining_ = tele;
    this.score_ = 0;
    this.latest_result_ = MoveResult.CONTINUE;

    this.board_.init(this.round_);

    let expected_score = 0;
    for (let r = 1; r < this.round_; ++r) {
      expected_score += nrobots_per_round(r);
    }
    this.score_ = expected_score;
  }

  load_from_stringified_representation(str, round, n_safe_teles, score) {
    this.board_.load_from_stringified_representation(str);
    this.round_ = round;
    this.n_safe_teleports_remaining_ = n_safe_teles;
    this.score_ = score;
  }

  reset() {
    this.board_ = new Board();
    this.round_ = 0;
    this.n_safe_teleports_remaining_ = 0;
    this.score_ = 0;
    this.latest_result_ = MoveResult.CONTINUE;
    this.new_round();
  }

  get board() {
    return this.board_;
  }

  get n_safe_teleports_remaining() {
    return this.n_safe_teleports_remaining_;
  }

  get round() {
    return this.round_;
  }

  get latest_result() {
    return this.latest_result_;
  }

  game_is_over() {
    return (
      this.latest_result_ === MoveResult.YOU_WIN_GAME ||
      this.latest_result_ === MoveResult.YOU_LOSE
    );
  }

  get score() {
    return this.score_;
  }

  new_round() {
    let expected_score = 0;
    for (let r = 1; r <= this.round_; ++r) {
      expected_score += r * 10;
    }

    if (this.score_ !== expected_score) {
      console.log("Expected score is " + expected_score);
    }

    if (this.round_ === MAX_N_ROUNDS) {
      this.latest_result_ = MoveResult.YOU_WIN_GAME;
    } else {
      this.board_.init(++this.round_);
      if (sleepsize > 0) {
        // std::this_thread::sleep_for( std::chrono::milliseconds(sleepsize) );
        // Sleep functionality not available in JavaScript
        // You may need to implement an alternative
      }
    }
  }

  cascade(updater) {
    const n_robots_start = this.board_.n_robots();
    this.latest_result_ = MoveResult.CONTINUE;

    while (this.latest_result_ === MoveResult.CONTINUE) {
      this.latest_result_ = this.board_.move_robots_1_step();
      updater.render(this);
    }

    if (this.latest_result_ === MoveResult.YOU_WIN_ROUND) {
      this.score_ += n_robots_start;
      this.n_safe_teleports_remaining_ += n_robots_start;
      if (this.n_safe_teleports_remaining_ > 10)
        this.n_safe_teleports_remaining_ = 10;
      this.new_round();
    }

    return (
      this.latest_result_ === MoveResult.YOU_LOSE ||
      this.latest_result_ === MoveResult.YOU_WIN_GAME
    );
  }

  move_human(dx, dy) {
    const n_robots_start = this.board_.n_robots();
    this.latest_result_ = this.board_.move_human(dx, dy);
    this.score_ += n_robots_start - this.board_.n_robots();

    if (this.latest_result_ === MoveResult.YOU_WIN_ROUND) {
      this.new_round();
    }

    return (
      this.latest_result_ === MoveResult.YOU_LOSE ||
      this.latest_result_ === MoveResult.YOU_WIN_GAME
    );
  }

  danger_tele() {
    this.latest_result_ = this.board_.teleport(false);
    if (this.latest_result_ === MoveResult.CONTINUE) {
      RC_DEBUG_ASSERT(board_.n_robots() > 0);
    }
  }

  safe_tele() {
    this.latest_result_ = this.board_.teleport(true);
    this.n_safe_teleports_remaining_--;
  }

  teleport() {
    const n_robots_start = this.board_.n_robots();

    if (this.n_safe_teleports_remaining_ === 0) {
      this.danger_tele();
    } else {
      this.safe_tele();
    }

    this.score_ += n_robots_start - this.board_.n_robots();

    if (this.latest_result_ === MoveResult.YOU_WIN_ROUND) {
      this.new_round();
    } else if (this.latest_result_ === MoveResult.CONTINUE) {
      RC_DEBUG_ASSERT(board_.n_robots() > 0);
    }

    const game_over =
      this.latest_result_ === MoveResult.YOU_LOSE ||
      this.latest_result_ === MoveResult.YOU_WIN_GAME;
    return game_over;
  }

  // Function to handle keydown events
  handleKeyDown(event) {
    const key = event.key;

    switch (key) {
      case 'ArrowUp':
      case 'w':
        const moveResult = this.move_human(0, 1);
        break;
      case 'ArrowDown':
      case 's':
        const moveResult = this.move_human(0, -1);
        break;
      case 'ArrowLeft':
      case 'a':
        const moveResult = this.move_human(-1, 0);
        break;
      case 'ArrowRight':
      case 'd':
        const moveResult = this.move_human(1, 0);
        break;
    }
}

const Occupant = {
  EMPTY: 0,
  ROBOT: 1,
  HUMAN: 2,
  FIRE: 3,
  OOB: 4,
};

const MoveResult = {
  CONTINUE: 0,
  YOU_LOSE: 1,
  YOU_WIN_ROUND: 2,
  YOU_WIN_GAME: 3,
};


    const boardElement = document.querySelector('.board');
    const cells = [];

    // Create the cells on the board
    for (let i = 0; i < Board.WIDTH; i++) {
      cells[i] = [];
      for (let j = 0; j < Board.HEIGHT; j++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.x = i;
        cell.dataset.y = j;
        boardElement.appendChild(cell);
        cells[i][j] = cell;
      }
    }

    // Initialize and start the game
    const game = new RobotsGame();
    game.start();
    renderBoard();

    // Add event listeners to the cells for player interaction
    cells.forEach((row) => {
      row.forEach((cell) => {
        cell.addEventListener('click', () => {
          const x = parseInt(cell.dataset.x);
          const y = parseInt(cell.dataset.y);
          const moveResult = game.makeMove(x, y);
          renderBoard();

          if (moveResult === MoveResult.YOU_LOSE) {
            alert('Game over! You lost.');
          } else if (moveResult === MoveResult.YOU_WIN_ROUND) {
            alert('You won the round!');
          }
        });
      });
    });

    // Function to render the current state of the board
    function renderBoard() {
      const board = game.board_;

      for (let i = 0; i < Board.WIDTH; i++) {
        for (let j = 0; j < Board.HEIGHT; j++) {
          const cell = cells[i][j];
          cell.className = 'cell';

          switch (board.cell({ x: i, y: j })) {
            case Occupant.HUMAN:
              cell.classList.add('human');
              break;
            case Occupant.ROBOT:
              cell.classList.add('robot');
              break;
            case Occupant.FIRE:
              cell.classList.add('fire');
              break;
          }
        }
      }
    }
  </script>
</body>
</html>
